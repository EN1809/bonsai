
in vec2 gBufferUV;
layout (location = 0) out vec4 LightColor;
layout (location = 1) out vec3 BloomColor;

uniform sampler2D gColor;
uniform sampler2D gPosition;
uniform sampler2D gNormal;
uniform sampler2D shadowMap;
uniform sampler2D Ssao;

uniform s32 LightCount;
uniform r32 LightIndexToUV;
uniform sampler2D LightColors;
uniform sampler2D LightPositions;

uniform sampler2D TransparencyAccum;
uniform sampler2D TransparencyCount;
uniform bool BravoilMyersOIT;
uniform bool BravoilMcGuireOIT;

uniform mat4 ShadowMVP;

uniform vec3 SunPosition;
uniform vec3 SunColor;
uniform vec3 CameraP;

uniform bool UseSsao;
uniform bool UseShadowMapping;
uniform bool UseLightingBloom;

int AoBlurSize = 4; // size of AO noise texture
float BlurredAO = 0.0f;


// NOTE(Jesse): Better shader noise function for when I need it : https://www.shadertoy.com/view/4djSRW

// NOTE(Jesse): These are done, leaving here for posterity for a bit.
// DONE(Jesse): Tune the sun color & ambient light color to be orange/teal
// DONE(Jesse): Tune the sun color & ambient light intensities to be 10:1
// DONE(Jesse): Add back-lighting, which is a light from the opposite direciton of the sun.  
// DONE(Jesse): Don't modulate key-light by SSAO
//
// https://www.youtube.com/watch?v=-pdSjBPH3zM
//

// SunIntensity : 1.00f Full Sun
// SunIntensity : 0.05f Dusk
// SunIntensity : 0.005f Moonlight

/* float SunIntensity = 0.0005f;
/* float SunIntensity = 0.005f; */
/* float SunIntensity = 0.05f; */
float SunIntensity = 0.5f;
/* float SunIntensity = 1.0f; */

// Tuning
  float gamma = 2.2f;
  float materialShininess = 2.0f;
//


vec3 SpecLightingCalc(float AttenuationFactor, vec3 DiffuseColor, vec3 FragToLight, vec3 FragPosition, vec3 FragNormal, vec3 CameraP)
{
  vec3 reflectionVector = reflect(FragToLight, FragNormal);
  vec3 FragToCamera = normalize(FragPosition - CameraP);
  float cosAngle = max(0.0, dot(FragToCamera, reflectionVector));
  float SpecularPower = pow(cosAngle, materialShininess);
  vec3 SpecularLight = DiffuseColor * SpecularPower;

  return SpecularLight;
}

vec3 DiffuseLightingCalc(float AttenuationFactor, vec3 DiffuseColor, vec3 LightColor, vec3 FragToLight, vec3 FragNormal, vec3 CameraP)
{
  float LightCosTheta = clamp( dot( FragNormal, FragToLight), 0.0f, 1.0f);
  vec3 DirectLight = DiffuseColor * LightColor * LightCosTheta * AttenuationFactor;
  return DirectLight;
}


void main()
{
  vec2 gBufferTextureDim = vec2(SCR_WIDTH, SCR_HEIGHT);
  ivec2 texelCoord = ivec2(gBufferUV*gBufferTextureDim);
  vec4 FragPosition = texelFetch(gPosition, texelCoord, 0);

  vec4 AccumTex = texture(TransparencyAccum, gBufferUV);
  float AccumCountTex = max(1.f, texture(TransparencyCount, gBufferUV).r);

  vec3 KeyLightContrib = vec3(0.f);
  vec3 BackLightContrib = vec3(0.f);
  vec3 CameraToFrag = normalize(FragPosition.xyz - CameraP); // TODO(Jesse): Pass this to the lighting calc that needs it

  vec4 gColorTexel = texelFetch(gColor, texelCoord, 0);

  vec3 Diffuse = gColorTexel.rgb;
  float Emission = gColorTexel.a;

  /* Diffuse *= Emission; */

  vec3 FragNormal = texelFetch(gNormal, texelCoord, 0).rgb;
  /* vec3 FragNormal   = texture(gNormal, gBufferUV).rgb; */

  vec3 ShadowVisibility = vec3(1.0f);

  vec3 TotalLight = vec3(0.f);
  /* r32 DiscardThresh = f32_MAX; */
  /* if (FragPosition.x == DiscardThresh) */
  /* { */
  /*   TotalLight = vec3(1.f); */
  /* } */
  /* else */
  {
    /* LightColor = V4(FragPosition, 1.f); */
    /* return; */


    /* float Emission = clamp(0.f, 1.f, texelFetch(gColor, texelCoord, 0).a); */

    {
      vec3 FragToLight = normalize(SunPosition);
      vec3 LightToFrag = -FragToLight;

      float LightAtt = SunIntensity;
      KeyLightContrib = DiffuseLightingCalc(LightAtt, Diffuse, SunColor, FragToLight, FragNormal, CameraP);
      /* KeyLightContrib += SpecLightingCalc(LightAtt, Diffuse, FragToLight, FragPosition, FragNormal, CameraP); */

      BackLightContrib = DiffuseLightingCalc(LightAtt, Diffuse, 0.15f*SunColor, LightToFrag, FragNormal, CameraP);
    }



    vec3 PointLightsContrib = V3(0.f);
    for ( s32 LightIndex = 0; LightIndex < LightCount; ++LightIndex )
    {
      ivec2 LightUV = ivec2(LightIndex, 0);

      vec3 LightPosition = texelFetch(LightPositions, LightUV, 0).rgb;
      vec3 LightColor = texelFetch(LightColors, LightUV, 0).rgb;

      vec3 FragToLight = normalize(LightPosition - FragPosition.xyz);

      float LightCosTheta = clamp( dot( FragNormal, FragToLight), 0.0f, 1.0f);

      float Distance = distance(FragPosition.xyz, LightPosition);
      float LightAtt = 1.0f/(Distance*Distance);

      vec3 reflectionVector = reflect(FragToLight, FragNormal);
      vec3 CameraToFrag = normalize(FragPosition.xyz - CameraP);
      float cosAngle = max(0.f, dot(CameraToFrag, reflectionVector));
      float SpecularPower = pow(cosAngle, materialShininess);

      vec3 DirectLight = Diffuse * LightColor * LightCosTheta * LightAtt;
      vec3 SpecularLight = vec3(0.f);

      if (LightCosTheta > 0.f) SpecularLight = LightColor * SpecularPower * LightAtt;

      PointLightsContrib += DirectLight + SpecularLight;
      /* PointLightsContrib += SpecularLight; */
    }

    if (UseSsao)
    {
      vec2 texelSize = 1.0 / vec2(textureSize(Ssao, 0));
      float AccumAO = 0.0;

      vec2 hlim = vec2(float(-AoBlurSize) * 0.5 + 0.5);

      for (int i = 0; i < AoBlurSize; ++i) {
         for (int j = 0; j < AoBlurSize; ++j) {
            vec2 TexOffset = (hlim + vec2(float(i), float(j))) * texelSize;
            AccumAO += texture(Ssao, gBufferUV + TexOffset).r;
         }
      }

      BlurredAO = AccumAO / float(AoBlurSize * AoBlurSize);
    }
    else
    {
      BlurredAO = 1.0f;
    }


    vec3 sampleVis = vec3(1.0f/5.f);
    /* vec3 sampleVis = vec3(1.f/7.f); */

    if (UseShadowMapping)
    {
      /*
       *  Shadow Mapping
       */
      float acneBias = 0.0001f; // Fix acne

      vec4 FragPShadowSpace = ShadowMVP * vec4(FragPosition.xyz, 1.f);
      float FragDepth = FragPShadowSpace.z - acneBias;
      /* LightColor = vec4(FragDepth, FragDepth, FragDepth, 1.f); */
      /* LightColor = FragPShadowSpace; */
      /* return; */


      v2 ShadowMapUVStep = vec2(1.f)/vec2(float(SHADOW_MAP_RESOLUTION_X), float(SHADOW_MAP_RESOLUTION_Y));

      float ShadowSampleDepth = texture(shadowMap, FragPShadowSpace.xy ).x + acneBias;
      if ( FragDepth > ShadowSampleDepth ) { ShadowVisibility -= vec3(1.f); }

      // NOTE(Jesse): This is misguided.  The correct thing to do is to write
      // shadow information to a buffer, then sample that buffer using a box filter
      // (or some other blur function).  The reason to do it that way instead of
      // directly here is that for each sample you take here, you'd have to
      // recompute the actual shadow map value at the sample pos, which would be
      // much too expensive even at small sample rates.
      //
      // I'm going to leave this here, but it causes flashing when the sun rotates
      // such that the number of samples this hits true branches for change for the
      // whole scene.
      //
      // Might be fine if the sun location was a fixed point, but that seems lame.
      //
#if 0
      // TODO(Jesse): Does this produce better results using texelFetch?
      vec2 Mapped = vec2(FragPShadowSpace.xy + vec2(ShadowMapUVStep.x, 0.f));
      ShadowSampleDepth = texture(shadowMap, Mapped).x + acneBias;
      if ( FragDepth > ShadowSampleDepth ) { ShadowVisibility -= sampleVis; }

      Mapped = vec2(FragPShadowSpace.xy + vec2(-ShadowMapUVStep.x, 0.f));
      ShadowSampleDepth = texture(shadowMap, Mapped).x + acneBias;
      if ( FragDepth > ShadowSampleDepth ) { ShadowVisibility -= sampleVis; }

      Mapped = vec2(FragPShadowSpace.xy + vec2(0.f, ShadowMapUVStep.y));
      ShadowSampleDepth = texture(shadowMap, Mapped).x + acneBias;
      if ( FragDepth > ShadowSampleDepth ) { ShadowVisibility -= sampleVis; }

      Mapped = vec2(FragPShadowSpace.xy + vec2(0.f, -ShadowMapUVStep.y));
      ShadowSampleDepth = texture(shadowMap, Mapped).x + acneBias;
      if ( FragDepth > ShadowSampleDepth ) { ShadowVisibility -= sampleVis; }
#endif

      /* LightColor = vec4(vec3(FragDepth < ShadowSampleDepth ), 1.f); */
      /* return; */

    }

    /* ShadowVisibility = max(ShadowVisibility, vec3(SunIntensity)); */
    /* LightColor = vec4(ShadowVisibility, 1.f); */
    /* return; */

#if 0
    /*
     *  Fog
     */
    // TODO(Jesse): Can do squared?
    float DistanceToFrag = distance(CameraP, FragPosition.xyz);
    float MaxFogDist = 4500.f;

    float FogContrib = clamp( DistanceToFrag / MaxFogDist, 0.f, 1.f);
    v3 FogColor = V3(0.01f, 0.04f, 0.20f);
    v3 Fog = FogContrib * FogColor;
#else
    v3 Fog = V3(0);
#endif

    /*
     *  Tone-mapping && gamma correction
     */

    TotalLight = (KeyLightContrib*ShadowVisibility) +
                 (BackLightContrib*BlurredAO) +
                 (PointLightsContrib*BlurredAO) +
                 Fog;
                 /* Emission * Diffuse + */

    /* if (Emission > 1.f) */
    /* { */
    /*   TotalLight += Emission*Diffuse; */
    /* } */

    /* vec3 TotalLight = (KeyLightContrib) + */
    /*                   (PointLightsContrib) + */
    /*                   (BlurredAO*BackLightContrib) + */
    /*                   Fog; */

  }

  float Shine = 0.f;
  /* Shine = clamp(pow(dot(SunPosition, CameraToFrag), 2.f), 0.f, 1.f); */


  /* LightColor = vec4(Diffuse, 1.f); */
  /* LightColor = vec4(abs(FragNormal), 1.f); */
  /* LightColor = vec4(KeyLightContrib*10.f, 1.f); */

  /* LightColor = vec4( (KeyLightContrib*ShadowVisibility*100.f), 1.f); */
  /* LightColor = vec4( (ShadowVisibility), 1.f); */
  /* LightColor = vec4(FogContrib, FogContrib, FogContrib, 1.f) * vec4(FogColor, 1.f); */
  /* LightColor = vec4(LightColor, 1.f); */
  /* LightColor = vec4(1.f, 0.f, 0.f, 1.f); */
  /* LightColor = vec4(0.f); */

  LightColor = vec4(TotalLight, 1.f);
  if (UseLightingBloom)
  {
    v4 TransparencyContrib = v4(0.f, 0.f, 0.f, 0.f);

    if (BravoilMyersOIT)   { TransparencyContrib = BravoilMyersWeightedAverage(AccumTex, AccumCountTex); }
    if (BravoilMcGuireOIT) { TransparencyContrib = BravoilMcGuireDepthWeights(AccumTex, AccumCountTex); }

    BloomColor = TotalLight + (Emission*Diffuse) + TransparencyContrib.rgb;
  }
  /* else { BloomColor = vec3(0.0f, 0.0f, 0.0f); } */

  /* if (UseLightingBloom) LightColor.r = 1.f; */
  /* if (UseShadowMapping) LightColor.b = 1.f; */
  /* if (UseSsao) LightColor.g = 1.f; */

  /* LightColor = vec4(Emission, Emission, Emission, 1.f);; */
  /* BloomColor = vec3(Emission, Emission, Emission); */
}

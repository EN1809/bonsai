#version 310 es

precision highp float;
precision highp sampler2DShadow;

out vec4 color;

in vec2 UV;

uniform sampler2D gColor;
uniform sampler2D gNormal;
uniform sampler2D gPosition;
uniform sampler2D gDepth;

uniform sampler2D shadowMap;
// uniform sampler2DShadow shadowMap;

// This must match the corresponding define in constants.h
const int SSAO_KERNEL_SIZE = 16;

const vec3 UP = vec3(0,0,1);

uniform vec3 CameraPos;
uniform vec3 GlobalLightPosition;
uniform mat4 shadowMVP;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform vec3 SsaoKernel[SSAO_KERNEL_SIZE];

float exposure = 1.0f;
float gamma = 2.2f;

float GlobalLightIntensity = 1.0f;

//
//
//

vec2 poissonDisk[16] = vec2[](
   vec2( -0.94201624, -0.39906216 ),
   vec2(  0.94558609, -0.76890725 ),
   vec2( -0.09418410, -0.92938870 ),
   vec2(  0.34495938,  0.29387760 ),
   vec2( -0.91588581,  0.45771432 ),
   vec2( -0.81544232, -0.87912464 ),
   vec2( -0.38277543,  0.27676845 ),
   vec2(  0.97484398,  0.75648379 ),

   vec2(  0.44323325, -0.97511554 ),
   vec2(  0.53742981, -0.47373420 ),
   vec2( -0.26496911, -0.41893023 ),
   vec2(  0.79197514,  0.19090188 ),
   vec2( -0.24188840,  0.99706507 ),
   vec2( -0.81409955,  0.91437590 ),
   vec2(  0.19984126,  0.78641367 ),
   vec2(  0.14383161, -0.14100790 )
);

//
//
void main()
{
  vec3 Diffuse      = texture(gColor, UV).rgb;
  vec3 fragNormal   = texture(gNormal, UV).rgb; // modelspace
  vec3 fragPosition = texture(gPosition, UV).rgb; // worldspace
  vec3 fragDepth    = texture(gDepth, UV).rgb;


  vec3 Ambient = Diffuse * GlobalLightIntensity * 0.1f;

  vec3 GlobalLightDirection = GlobalLightPosition;
  float GlobalLightCosTheta = clamp( dot( fragNormal, GlobalLightDirection), 0.0f, 1.0f);

  /*
   *  AO
   */
  vec3 FragPositionViewSpace = (ViewMatrix * texture(gPosition, UV)).xyz;
  vec3 FragNormal_NDC = normalize(fragNormal * 2.0f - 1.0f); // Not sure this is correct in my case..

  vec3 tangent = cross(FragNormal_NDC, UP);
  vec3 bitangent = cross(FragNormal_NDC, tangent);

  mat3 tbn = mat3(tangent, bitangent, FragNormal_NDC);

  float AO = 0.0;
  for ( int KernelIndex = 0;
        KernelIndex < SSAO_KERNEL_SIZE;
        ++KernelIndex)
  {
    const float Radius = 1.0f; // For tuning

    vec3 SampleP = tbn * SsaoKernel[KernelIndex];
    SampleP = SampleP * Radius + FragPositionViewSpace;

    // project SampleP
    vec4 SampleUV = ProjectionMatrix * vec4(SampleP, 1);
    SampleUV.xy /= SampleUV.w;             // Perspective divide
    SampleUV.xy = SampleUV.xy * 0.5 + 0.5; // NDC to screen space [-1, 1] -> [0, 1]

    // get Sample depth:
    float sampleDepth = texture(gDepth, SampleUV.xy).r;

    // range check & accumulate:
    float rangeCheck = abs(FragPositionViewSpace.z - sampleDepth) < Radius ? 1.0 : 0.0;
    AO += (sampleDepth <= SampleP.z ? 1.0 : 0.0) * rangeCheck;
  }

  AO = 1.0f - (AO / float(SSAO_KERNEL_SIZE));

/*   for ( int PoissonIndex = 0; */
/*         PoissonIndex < AoSamples; */
/*         ++PoissonIndex ) */
/*   { */
/*     vec3 SampleViewSpace = (ViewMatrix * texture(gPosition, UV + ( poissonDisk[PoissonIndex]/200.0f) )).xyz; */

/*     float DistanceToSample = length( CameraViewSpace - SampleViewSpace ); */
/*     float DistanceToFrag = length( CameraViewSpace - FragViewSpace ); */

/*     if (DistanceToSample < DistanceToFrag) */
/*       AO += 1.0f; */
/*   } */

  /* AO = 1.0f - (AO/float(AoSamples)); */




  /*
   *  Shadow Mapping
   */
  vec4 FragPositionShadowSpace = shadowMVP * vec4(fragPosition, 1.0f);

  float FragDepthShadowSpace = FragPositionShadowSpace.z;

  float acneBias = 0.01f; // Fix acne
  float ShadowMapDepth = texture(shadowMap, FragPositionShadowSpace.xy).x + acneBias;

  vec3 visibility = vec3(1.0f);
  if ( ShadowMapDepth < FragDepthShadowSpace )
  {
    visibility = vec3(0.1f);
  }

  /* float visibility = 1.0f; */
  /* for (int i=0;i < 8;i++){ */
  /*   int index = i * 2; */
  /*   visibility -= 0.1*( 1.0 - texture(shadowMap, vec3(ShadowCoord.xy + poissonDisk[index]/1000.0,  (ShadowCoord.z-bias)/ShadowCoord.w) )); */
  /* } */






  /*
   *  HDR tone-mapping && gamma correction
   */
  vec3 hdrColor =
    Ambient
    + Diffuse * GlobalLightCosTheta * GlobalLightIntensity * vec3(visibility) * vec3(AO)
  ;

  // Reinhard tone mapping
  vec3 mapped = hdrColor / (hdrColor + vec3(1.0f));

  // Gamma correction
  color = vec4(pow(mapped, vec3(1.0f / gamma)), 1.0f);

  /* color = vec4(0); */
  /* color.a = 1.0f; */

  /* color.r = ShadowMapDepth; */
  /* color.r = FragDepthShadowSpace; */
  /* color.r = FragPositionShadowSpace.w; */

  /* color = vec4(fragDepth, 1); */
  /* color.xyz = vec3(AO); */
}

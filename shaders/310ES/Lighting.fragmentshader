#version 310 es

precision highp float;

out vec4 color;

in vec2 UV;

// This must match the corresponding define in constants.h
const int SSAO_KERNEL_SIZE = 1;
const vec3 UP = vec3(0,0,1);


uniform sampler2D gColor;
uniform sampler2D gPosition;
uniform sampler2D gNormal;
uniform sampler2D shadowMap;

uniform sampler2D SsaoNoiseTexture;
uniform vec2 SsaoNoiseTile;

uniform vec3 GlobalLightPosition;
uniform mat4 ShadowMVP;

uniform vec3 SsaoKernel[SSAO_KERNEL_SIZE];

// TODO(Jesse): This could be pre-multiplied by an NdcToScreenSpace matrix so
// each SSAO sample did not have to be re-biased in the hot loop.
uniform mat4 ViewProjection;

// Tuning
  float SsaoRadius = 1.0f;
  float exposure = 1.0f;
  float gamma = 2.2f;
  float GlobalLightIntensity = 1.0f;
//


//
//
//

vec2 poissonDisk[16] = vec2[](
   vec2( -0.94201624, -0.39906216 ),
   vec2(  0.94558609, -0.76890725 ),
   vec2( -0.09418410, -0.92938870 ),
   vec2(  0.34495938,  0.29387760 ),
   vec2( -0.91588581,  0.45771432 ),
   vec2( -0.81544232, -0.87912464 ),
   vec2( -0.38277543,  0.27676845 ),
   vec2(  0.97484398,  0.75648379 ),

   vec2(  0.44323325, -0.97511554 ),
   vec2(  0.53742981, -0.47373420 ),
   vec2( -0.26496911, -0.41893023 ),
   vec2(  0.79197514,  0.19090188 ),
   vec2( -0.24188840,  0.99706507 ),
   vec2( -0.81409955,  0.91437590 ),
   vec2(  0.19984126,  0.78641367 ),
   vec2(  0.14383161, -0.14100790 )
);

//
//
void main()
{
  vec3 Diffuse      = texture(gColor, UV).rgb;
  vec3 FragNormal   = texture(gNormal, UV).rgb;   // modelspace
  vec3 FragPosition = texture(gPosition, UV).rgb; // worldspace
  float FragDepth   = texture(gPosition, UV).w;   // Linear

  vec3 Ambient = Diffuse * GlobalLightIntensity * 0.1f;

  vec3 GlobalLightDirection = GlobalLightPosition;
  float GlobalLightCosTheta = clamp( dot( FragNormal, GlobalLightDirection), 0.0f, 1.0f);



  /*
   *  AO
   */

  vec3 Noise = texture(SsaoNoiseTexture, UV*SsaoNoiseTile).xyz;
  vec3 Right = normalize(Noise - FragNormal);
  vec3 Front = cross(FragNormal, Right);
  mat3 Reorientation = mat3(Right, Front, FragNormal);

  float AO = 1.0f;
  float OccluderContribution = 1.0f/float(SSAO_KERNEL_SIZE);

  // NOTE(Jesse): I was getting some artifacts when at 90deg to a surface so I
  // added a bias to the sample.
  float AoBias = 0.00005f;
  float AoBiasFragDepth = FragDepth - AoBias;

  for ( int KernelIndex = 0;
        KernelIndex < SSAO_KERNEL_SIZE;
        ++KernelIndex)
  {
    vec3 KernelP = Reorientation * SsaoKernel[KernelIndex] * SsaoRadius;
    vec3 SampleP = KernelP + FragPosition;

    // Project SampleP
    vec4 Projected = ViewProjection * vec4(SampleP, 1);

    // Prespective divide
    vec2 SampleUV = Projected.xy / Projected.w;

    // NDC to screen space [-1, 1] -> [0, 1]
    SampleUV = (SampleUV.xy * 0.5) + 0.5;

    // get Sample depth:
    float sampleDepth = texture(gPosition, SampleUV).w;

    bool Occluded = sampleDepth <= AoBiasFragDepth;

    float Diff = abs(AoBiasFragDepth - sampleDepth);
    bool InsideRadius = Diff < 0.0016f; // TODO(Jesse): In the john-chapman article this was the radius value - how?

    if (Occluded && InsideRadius)
    {
      AO -= OccluderContribution;
    }

  }



  /*
   *  Shadow Mapping
   */
  vec4 FragPShadowScreenSpace = ShadowMVP * vec4(FragPosition, 1.0f);

  float FragPShadowDepth = FragPShadowScreenSpace.z;

  float acneBias = 0.01f; // Fix acne
  float ShadowDepth = texture(shadowMap, FragPShadowScreenSpace.xy).x + acneBias;

  vec3 visibility = vec3(1.0f);
  if ( FragPShadowDepth > ShadowDepth )
  {
    visibility = vec3(0.1f);
  }

  /* float visibility = 1.0f; */
  /* for (int i=0;i < 8;i++){ */
  /*   int index = i * 2; */
  /*   visibility -= 0.1*( 1.0 - texture(shadowMap, vec3(ShadowCoord.xy + poissonDisk[index]/1000.0,  (ShadowCoord.z-bias)/ShadowCoord.w) )); */
  /* } */






  /*
   *  HDR tone-mapping && gamma correction
   */
  vec3 hdrColor =
    Ambient
    + Diffuse * GlobalLightCosTheta * GlobalLightIntensity * vec3(visibility)  * vec3(AO)
  ;

  // Reinhard tone mapping
  vec3 mapped = hdrColor / (hdrColor + vec3(1.0f));

  // Gamma correction
  color = vec4(pow(mapped, vec3(1.0f / gamma)), 1.0f);
  vec3 ShadowMap = texture(shadowMap, UV).xyz;
}

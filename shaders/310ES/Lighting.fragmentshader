#version 310 es

precision highp float;
precision highp sampler2DShadow;

out vec4 color;

in vec2 UV;

// This must match the corresponding define in constants.h
const int SSAO_KERNEL_SIZE = 16;
const vec3 UP = vec3(0,0,1);


uniform sampler2D gColor;
uniform sampler2D gPosition;
uniform sampler2D gNormal;
uniform sampler2D shadowMap;

uniform sampler2D SsaoNoiseTexture;
uniform vec2 SsaoNoiseTile;

uniform vec3 GlobalLightPosition;
uniform mat4 shadowMVP;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform vec3 SsaoKernel[SSAO_KERNEL_SIZE];

float exposure = 1.0f;
float gamma = 2.2f;

float GlobalLightIntensity = 1.0f;

//
//
//

vec2 poissonDisk[16] = vec2[](
   vec2( -0.94201624, -0.39906216 ),
   vec2(  0.94558609, -0.76890725 ),
   vec2( -0.09418410, -0.92938870 ),
   vec2(  0.34495938,  0.29387760 ),
   vec2( -0.91588581,  0.45771432 ),
   vec2( -0.81544232, -0.87912464 ),
   vec2( -0.38277543,  0.27676845 ),
   vec2(  0.97484398,  0.75648379 ),

   vec2(  0.44323325, -0.97511554 ),
   vec2(  0.53742981, -0.47373420 ),
   vec2( -0.26496911, -0.41893023 ),
   vec2(  0.79197514,  0.19090188 ),
   vec2( -0.24188840,  0.99706507 ),
   vec2( -0.81409955,  0.91437590 ),
   vec2(  0.19984126,  0.78641367 ),
   vec2(  0.14383161, -0.14100790 )
);

//
//
void main()
{
  vec3 Diffuse      = texture(gColor, UV).rgb;
  vec3 FragNormal   = texture(gNormal, UV).rgb;   // modelspace
  vec3 FragPosition = texture(gPosition, UV).rgb; // worldspace
  float fragDepth   = texture(gPosition, UV).w;   // Linear


  vec3 Ambient = Diffuse * GlobalLightIntensity * 0.1f;

  vec3 GlobalLightDirection = GlobalLightPosition;
  float GlobalLightCosTheta = clamp( dot( FragNormal, GlobalLightDirection), 0.0f, 1.0f);



  /*
   *  AO
   */

  vec3 Noise = texture(SsaoNoiseTexture, UV*SsaoNoiseTile).xyz;
  vec3 Right = normalize(Noise - FragNormal);
  vec3 Front = cross(FragNormal, Right);
  mat3 Reorientation = mat3(Right, Front, FragNormal);

  // NOTE(Jesse): I was getting some artifacts when at 90deg to a surface so I
  // added a bias to the sample.
  float AoSampleBias = 0.00005f;

  float AO = 1.0f;
  float OccluderContribution = 1.0f/float(SSAO_KERNEL_SIZE);

  for ( int KernelIndex = 0;
        KernelIndex < SSAO_KERNEL_SIZE;
        ++KernelIndex)
  {
    const float Radius = 0.8f; // For tuning

    vec3 KernelP = Reorientation * SsaoKernel[KernelIndex] * Radius;
    vec3 SampleP = KernelP + FragPosition;

    // Project SampleP
    vec4 Projected = ProjectionMatrix * ViewMatrix * vec4(SampleP, 1);

    // Prespective divide
    vec2 SampleUV = Projected.xy / Projected.w;

    // NDC to screen space [-1, 1] -> [0, 1]
    SampleUV = SampleUV.xy * 0.5 + 0.5;

    // get Sample depth:
    float sampleDepth = texture(gPosition, SampleUV.xy).w + AoSampleBias;;

    bool Occluded = sampleDepth <= fragDepth;

    float Diff = abs(fragDepth - sampleDepth);
    bool InsideRadius = Diff < 0.0016f; // TODO(Jesse): In the john-chapman article this was the radius value - how?

    if (Occluded && InsideRadius)
    {
      AO -= OccluderContribution;
    }

  }



  /*
   *  Shadow Mapping
   */
  vec4 FragPositionShadowSpace = shadowMVP * vec4(FragPosition, 1.0f);

  float FragDepthShadowSpace = FragPositionShadowSpace.z;

  float acneBias = 0.01f; // Fix acne
  float ShadowMapDepth = texture(shadowMap, FragPositionShadowSpace.xy).x + acneBias;

  vec3 visibility = vec3(1.0f);
  if ( ShadowMapDepth < FragDepthShadowSpace )
  {
    visibility = vec3(0.1f);
  }

  /* float visibility = 1.0f; */
  /* for (int i=0;i < 8;i++){ */
  /*   int index = i * 2; */
  /*   visibility -= 0.1*( 1.0 - texture(shadowMap, vec3(ShadowCoord.xy + poissonDisk[index]/1000.0,  (ShadowCoord.z-bias)/ShadowCoord.w) )); */
  /* } */






  /*
   *  HDR tone-mapping && gamma correction
   */
  vec3 hdrColor =
    Ambient
    + Diffuse * GlobalLightCosTheta * GlobalLightIntensity * vec3(visibility) * vec3(AO)
  ;

  // Reinhard tone mapping
  vec3 mapped = hdrColor / (hdrColor + vec3(1.0f));

  // Gamma correction
  /* mapped.rgb = vec3(AO); */
  color = vec4(pow(mapped, vec3(1.0f / gamma)), 1.0f);

  /* color = vec4(0,0,0,1); */

  //color.rgb = Diffuse;
  /* color.rgb = Noise; */
  color.rgb = vec3(AO);

}

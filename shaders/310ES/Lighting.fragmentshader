#version 310 es

precision highp float;

in vec2 UV;
out vec4 color;


uniform sampler2D gColor;
uniform sampler2D gPosition;
uniform sampler2D gNormal;
uniform sampler2D shadowMap;
uniform sampler2D Ssao;


uniform vec3 GlobalLightPosition;
uniform mat4 ShadowMVP;

int AoBlurSize = 4; // size of AO noise texture
float BlurredAO = 0.0f;

// Tuning
  float exposure = 1.0f;
  float gamma = 2.2f;
  float GlobalLightIntensity = 1.0f;
//

vec2 poissonDisk[16] = vec2[](
   vec2( -0.94201624, -0.39906216 ),
   vec2(  0.94558609, -0.76890725 ),
   vec2( -0.09418410, -0.92938870 ),
   vec2(  0.34495938,  0.29387760 ),
   vec2( -0.91588581,  0.45771432 ),
   vec2( -0.81544232, -0.87912464 ),
   vec2( -0.38277543,  0.27676845 ),
   vec2(  0.97484398,  0.75648379 ),

   vec2(  0.44323325, -0.97511554 ),
   vec2(  0.53742981, -0.47373420 ),
   vec2( -0.26496911, -0.41893023 ),
   vec2(  0.79197514,  0.19090188 ),
   vec2( -0.24188840,  0.99706507 ),
   vec2( -0.81409955,  0.91437590 ),
   vec2(  0.19984126,  0.78641367 ),
   vec2(  0.14383161, -0.14100790 )
);







void main()
{
  vec3 Diffuse      = texture(gColor, UV).rgb;
  vec3 FragNormal   = texture(gNormal, UV).rgb;   // modelspace
  vec3 FragPosition = texture(gPosition, UV).rgb; // worldspace

  vec3 Ambient = Diffuse * GlobalLightIntensity * 0.1f;

  vec3 GlobalLightDirection = GlobalLightPosition;
  float GlobalLightCosTheta = clamp( dot( FragNormal, GlobalLightDirection), 0.0f, 1.0f);


  vec2 texelSize = 1.0 / vec2(textureSize(Ssao, 0));
  float AccumAO = 0.0;

  vec2 hlim = vec2(float(-AoBlurSize) * 0.5 + 0.5);

  for (int i = 0; i < AoBlurSize; ++i) {
     for (int j = 0; j < AoBlurSize; ++j) {
        vec2 TexOffset = (hlim + vec2(float(i), float(j))) * texelSize;
        AccumAO += texture(Ssao, UV + TexOffset).r;
     }
  }

  BlurredAO = AccumAO / float(AoBlurSize * AoBlurSize);


  /*
   *  Shadow Mapping
   */
  vec4 FragPShadowScreenSpace = ShadowMVP * vec4(FragPosition, 1.0f);

  float FragPShadowDepth = FragPShadowScreenSpace.z;

  float acneBias = 0.01f; // Fix acne
  float ShadowDepth = texture(shadowMap, FragPShadowScreenSpace.xy).x + acneBias;

  vec3 visibility = vec3(1.0f);
  if ( FragPShadowDepth > ShadowDepth )
  {
    visibility = vec3(0.1f);
  }

  /* float visibility = 1.0f; */
  /* for (int i=0;i < 8;i++){ */
  /*   int index = i * 2; */
  /*   visibility -= 0.1*( 1.0 - texture(shadowMap, vec3(ShadowCoord.xy + poissonDisk[index]/1000.0,  (ShadowCoord.z-bias)/ShadowCoord.w) )); */
  /* } */






  /*
   *  HDR tone-mapping && gamma correction
   */
  vec3 hdrColor =
    Ambient
    + Diffuse * GlobalLightCosTheta * GlobalLightIntensity * vec3(visibility) * vec3(BlurredAO)
  ;

  // Reinhard tone mapping
  vec3 mapped = hdrColor / (hdrColor + vec3(1.0f));

  // Gamma correction
  color = vec4(pow(mapped, vec3(1.0f / gamma)), 1.0f);
}

in vec2 UV;
out float Output;

uniform sampler2D gColor;
uniform sampler2D gPosition;
uniform sampler2D gNormal;

uniform sampler2D SsaoNoiseTexture;
uniform vec3 SsaoNoiseTile;

// This must match the corresponding define in constants.h
const int SSAO_KERNEL_SIZE = 8;
uniform vec3 SsaoKernel[SSAO_KERNEL_SIZE];

uniform mat4 ViewProjection;

// Tuning
  float SsaoRadius = 0.85f;
  float DepthThreshold = 0.004f;
//

void main()
{
#if USE_AO_SHADER
  vec3  FragNormal   = texture(gNormal,   UV).rgb; // modelspace
  vec3  FragPosition = texture(gPosition, UV).rgb; // worldspace
  float FragDepth    = texture(gPosition, UV).w;   // Linear


  vec3 Noise = texture(SsaoNoiseTexture, UV*SsaoNoiseTile.xy).xyz;

  vec3 Right = normalize(Noise - FragNormal);
  vec3 Front = cross(FragNormal, Right);
  mat3 Reorientation = mat3(Right, Front, FragNormal) * SsaoRadius;

  float AO = 1.0f;
  float OccluderContribution = 1.0f/float(SSAO_KERNEL_SIZE);

  // NOTE(Jesse): I was getting some artifacts when at 90deg to a surface so I
  // added a bias to the sample.
  float AoBias = 0.0008f;
  float AoBiasFragDepth = FragDepth - AoBias;

  for ( int KernelIndex = 0;
        KernelIndex < SSAO_KERNEL_SIZE;
        ++KernelIndex)
  {
    vec3 KernelP = Reorientation * SsaoKernel[KernelIndex];
    vec3 SampleP = KernelP + FragPosition;

    // Project SampleP
    vec4 Projected = ViewProjection * vec4(SampleP, 1);

    // Prespective divide
    vec2 SampleUV = Projected.xy / Projected.w;

    // NDC to screen space [-1, 1] -> [0, 1]
    SampleUV = (SampleUV.xy * 0.5) + 0.5;

    // get Sample depth:
    float sampleDepth = texture(gPosition, SampleUV).w;

    float DepthDelta = (AoBiasFragDepth - sampleDepth);
    float Occluded = clamp((DepthDelta * 10000000.0f), 0.0f, 1.0f);

    // TODO(Jesse): Can this be made into a multiplier instead of checking
    // against DepthDelta somehow?
    /* float DistanceFalloff = (1.0f/ (1.0f+DepthDelta) ); */

    if (DepthDelta < DepthThreshold)
      AO -= (OccluderContribution * Occluded);
  }

  Output = AO;
#else
  Output = 1.0f;
#endif

}
